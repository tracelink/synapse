/*
 * Veracode Summary Report API
 * Veracode Summary Report API Documentation
 *
 * OpenAPI spec version: v2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.tracelink.prodsec.lib.veracode.api.rest.model;

import java.math.BigDecimal;
import java.util.Objects;

import com.google.gson.annotations.SerializedName;

/**
 * For a static analysis, a list of modules with one module node per module
 * analyzed. For a dynamic analysis, a single module node.
 */
public class AnalysisType {
	@SerializedName("modules")
	private Module modules = null;

	@SerializedName("rating")
	private String rating = null;

	@SerializedName("score")
	private Long score = null;

	@SerializedName("mitigated_rating")
	private String mitigatedRating = null;

	@SerializedName("mitigated_score")
	private Long mitigatedScore = null;

	@SerializedName("submitted_date")
	private String submittedDate = null;

	@SerializedName("published_date")
	private String publishedDate = null;

	@SerializedName("next_scan_due")
	private String nextScanDue = null;

	@SerializedName("analysis_size_bytes")
	private BigDecimal analysisSizeBytes = null;

	@SerializedName("engine_version")
	private String engineVersion = null;

	@SerializedName("dynamic_scan_type")
	private DynamicScanType dynamicScanType = null;

	@SerializedName("scan_exit_status_id")
	private Long scanExitStatusId = null;

	@SerializedName("scan_exit_status_desc")
	private String scanExitStatusDesc = null;

	@SerializedName("version")
	private String version = null;

	public AnalysisType modules(Module modules) {
		this.modules = modules;
		return this;
	}

	/**
	 * Get modules
	 * 
	 * @return modules
	 **/
	public Module getModules() {
		return modules;
	}

	public void setModules(Module modules) {
		this.modules = modules;
	}

	public AnalysisType rating(String rating) {
		this.rating = rating;
		return this;
	}

	/**
	 * Letter grade for the security of this application.
	 * 
	 * @return rating
	 **/
	public String getRating() {
		return rating;
	}

	public void setRating(String rating) {
		this.rating = rating;
	}

	public AnalysisType score(Long score) {
		this.score = score;
		return this;
	}

	/**
	 * Numeric security score for this application.
	 * 
	 * @return score
	 **/
	public Long getScore() {
		return score;
	}

	public void setScore(Long score) {
		this.score = score;
	}

	public AnalysisType mitigatedRating(String mitigatedRating) {
		this.mitigatedRating = mitigatedRating;
		return this;
	}

	/**
	 * Letter grade for the security of this application, based on mitigated
	 * findings.
	 * 
	 * @return mitigatedRating
	 **/
	public String getMitigatedRating() {
		return mitigatedRating;
	}

	public void setMitigatedRating(String mitigatedRating) {
		this.mitigatedRating = mitigatedRating;
	}

	public AnalysisType mitigatedScore(Long mitigatedScore) {
		this.mitigatedScore = mitigatedScore;
		return this;
	}

	/**
	 * Numeric security score for this application, based on mitigated findings.
	 * 
	 * @return mitigatedScore
	 **/
	public Long getMitigatedScore() {
		return mitigatedScore;
	}

	public void setMitigatedScore(Long mitigatedScore) {
		this.mitigatedScore = mitigatedScore;
	}

	public AnalysisType submittedDate(String submittedDate) {
		this.submittedDate = submittedDate;
		return this;
	}

	/**
	 * Date when you submitted this application to Veracode for analysis.
	 * 
	 * @return submittedDate
	 **/
	public String getSubmittedDate() {
		return submittedDate;
	}

	public void setSubmittedDate(String submittedDate) {
		this.submittedDate = submittedDate;
	}

	public AnalysisType publishedDate(String publishedDate) {
		this.publishedDate = publishedDate;
		return this;
	}

	/**
	 * Date when Veracode published the analysis for this application.
	 * 
	 * @return publishedDate
	 **/
	public String getPublishedDate() {
		return publishedDate;
	}

	public void setPublishedDate(String publishedDate) {
		this.publishedDate = publishedDate;
	}

	public AnalysisType nextScanDue(String nextScanDue) {
		this.nextScanDue = nextScanDue;
		return this;
	}

	/**
	 * Date when the active security policy for this application is scheduled to
	 * request the next scan.
	 * 
	 * @return nextScanDue
	 **/
	public String getNextScanDue() {
		return nextScanDue;
	}

	public void setNextScanDue(String nextScanDue) {
		this.nextScanDue = nextScanDue;
	}

	public AnalysisType analysisSizeBytes(BigDecimal analysisSizeBytes) {
		this.analysisSizeBytes = analysisSizeBytes;
		return this;
	}

	/**
	 * Optional. For a static analysis, the size, in bytes, of the scanned modules.
	 * 
	 * @return analysisSizeBytes
	 **/
	public BigDecimal getAnalysisSizeBytes() {
		return analysisSizeBytes;
	}

	public void setAnalysisSizeBytes(BigDecimal analysisSizeBytes) {
		this.analysisSizeBytes = analysisSizeBytes;
	}

	public AnalysisType engineVersion(String engineVersion) {
		this.engineVersion = engineVersion;
		return this;
	}

	/**
	 * For a static analysis, the version of the engine that Veracode used for this
	 * scan.
	 * 
	 * @return engineVersion
	 **/
	public String getEngineVersion() {
		return engineVersion;
	}

	public void setEngineVersion(String engineVersion) {
		this.engineVersion = engineVersion;
	}

	public AnalysisType dynamicScanType(DynamicScanType dynamicScanType) {
		this.dynamicScanType = dynamicScanType;
		return this;
	}

	/**
	 * Get dynamicScanType
	 * 
	 * @return dynamicScanType
	 **/
	public DynamicScanType getDynamicScanType() {
		return dynamicScanType;
	}

	public void setDynamicScanType(DynamicScanType dynamicScanType) {
		this.dynamicScanType = dynamicScanType;
	}

	public AnalysisType scanExitStatusId(Long scanExitStatusId) {
		this.scanExitStatusId = scanExitStatusId;
		return this;
	}

	/**
	 * Optional. For a dynamic analysis, the numeric code for scan exit status.
	 * 
	 * @return scanExitStatusId
	 **/
	public Long getScanExitStatusId() {
		return scanExitStatusId;
	}

	public void setScanExitStatusId(Long scanExitStatusId) {
		this.scanExitStatusId = scanExitStatusId;
	}

	public AnalysisType scanExitStatusDesc(String scanExitStatusDesc) {
		this.scanExitStatusDesc = scanExitStatusDesc;
		return this;
	}

	/**
	 * Optional. For a dynamic analysis, a description for scan_exit_status_id.
	 * 
	 * @return scanExitStatusDesc
	 **/
	public String getScanExitStatusDesc() {
		return scanExitStatusDesc;
	}

	public void setScanExitStatusDesc(String scanExitStatusDesc) {
		this.scanExitStatusDesc = scanExitStatusDesc;
	}

	public AnalysisType version(String version) {
		this.version = version;
		return this;
	}

	/**
	 * Optional. Version of the scan.
	 * 
	 * @return version
	 **/
	public String getVersion() {
		return version;
	}

	public void setVersion(String version) {
		this.version = version;
	}

	@Override
	public boolean equals(java.lang.Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		AnalysisType analysisType = (AnalysisType) o;
		return Objects.equals(this.modules, analysisType.modules) && Objects.equals(this.rating, analysisType.rating)
				&& Objects.equals(this.score, analysisType.score)
				&& Objects.equals(this.mitigatedRating, analysisType.mitigatedRating)
				&& Objects.equals(this.mitigatedScore, analysisType.mitigatedScore)
				&& Objects.equals(this.submittedDate, analysisType.submittedDate)
				&& Objects.equals(this.publishedDate, analysisType.publishedDate)
				&& Objects.equals(this.nextScanDue, analysisType.nextScanDue)
				&& Objects.equals(this.analysisSizeBytes, analysisType.analysisSizeBytes)
				&& Objects.equals(this.engineVersion, analysisType.engineVersion)
				&& Objects.equals(this.dynamicScanType, analysisType.dynamicScanType)
				&& Objects.equals(this.scanExitStatusId, analysisType.scanExitStatusId)
				&& Objects.equals(this.scanExitStatusDesc, analysisType.scanExitStatusDesc)
				&& Objects.equals(this.version, analysisType.version);
	}

	@Override
	public int hashCode() {
		return Objects.hash(modules, rating, score, mitigatedRating, mitigatedScore, submittedDate, publishedDate,
				nextScanDue, analysisSizeBytes, engineVersion, dynamicScanType, scanExitStatusId, scanExitStatusDesc,
				version);
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("class AnalysisType {\n");

		sb.append("    modules: ").append(toIndentedString(modules)).append("\n");
		sb.append("    rating: ").append(toIndentedString(rating)).append("\n");
		sb.append("    score: ").append(toIndentedString(score)).append("\n");
		sb.append("    mitigatedRating: ").append(toIndentedString(mitigatedRating)).append("\n");
		sb.append("    mitigatedScore: ").append(toIndentedString(mitigatedScore)).append("\n");
		sb.append("    submittedDate: ").append(toIndentedString(submittedDate)).append("\n");
		sb.append("    publishedDate: ").append(toIndentedString(publishedDate)).append("\n");
		sb.append("    nextScanDue: ").append(toIndentedString(nextScanDue)).append("\n");
		sb.append("    analysisSizeBytes: ").append(toIndentedString(analysisSizeBytes)).append("\n");
		sb.append("    engineVersion: ").append(toIndentedString(engineVersion)).append("\n");
		sb.append("    dynamicScanType: ").append(toIndentedString(dynamicScanType)).append("\n");
		sb.append("    scanExitStatusId: ").append(toIndentedString(scanExitStatusId)).append("\n");
		sb.append("    scanExitStatusDesc: ").append(toIndentedString(scanExitStatusDesc)).append("\n");
		sb.append("    version: ").append(toIndentedString(version)).append("\n");
		sb.append("}");
		return sb.toString();
	}

	/**
	 * Convert the given object to string with each line indented by 4 spaces
	 * (except the first line).
	 */
	private String toIndentedString(java.lang.Object o) {
		if (o == null) {
			return "null";
		}
		return o.toString().replace("\n", "\n    ");
	}

}
