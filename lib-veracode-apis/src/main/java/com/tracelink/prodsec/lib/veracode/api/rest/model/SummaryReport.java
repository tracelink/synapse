/*
 * Veracode Summary Report API
 * Veracode Summary Report API Documentation
 *
 * OpenAPI spec version: v2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.tracelink.prodsec.lib.veracode.api.rest.model;

import java.math.BigDecimal;
import java.util.List;
import java.util.Objects;

import com.google.gson.annotations.SerializedName;

/**
 * Details about the Summary Report.
 */
public class SummaryReport {
	@SerializedName("static-analysis")
	private AnalysisType staticAnalysis = null;

	@SerializedName("dynamic-analysis")
	private AnalysisType dynamicAnalysis = null;

	@SerializedName("manual-analysis")
	private ManualAnalysisType manualAnalysis = null;

	@SerializedName("severity")
	private List<SeverityType> severity = null;

	@SerializedName("flaw-status")
	private FlawStatusType flawStatus = null;

	@SerializedName("custom_fields")
	private CustomFieldsType customFields = null;

	@SerializedName("software_composition_analysis")
	private SoftwareCompositionAnalysis softwareCompositionAnalysis = null;

	@SerializedName("report_format_version")
	private String reportFormatVersion = null;

	@SerializedName("account_id")
	private BigDecimal accountId = null;

	@SerializedName("app_name")
	private String appName = null;

	@SerializedName("app_id")
	private BigDecimal appId = null;

	@SerializedName("analysis_id")
	private BigDecimal analysisId = null;

	@SerializedName("static_analysis_unit_id")
	private BigDecimal staticAnalysisUnitId = null;

	@SerializedName("sandbox_name")
	private String sandboxName = null;

	@SerializedName("sandbox_id")
	private BigDecimal sandboxId = null;

	@SerializedName("first_build_submitted_date")
	private String firstBuildSubmittedDate = null;

	@SerializedName("version")
	private String version = null;

	@SerializedName("build_id")
	private BigDecimal buildId = null;

	@SerializedName("vendor")
	private String vendor = null;

	@SerializedName("submitter")
	private String submitter = null;

	@SerializedName("platform")
	private String platform = null;

	@SerializedName("business_criticality")
	private Long businessCriticality = null;

	@SerializedName("generation_date")
	private String generationDate = null;

	@SerializedName("veracode_level")
	private String veracodeLevel = null;

	@SerializedName("total_flaws")
	private Long totalFlaws = null;

	@SerializedName("flaws_not_mitigated")
	private Long flawsNotMitigated = null;

	@SerializedName("teams")
	private String teams = null;

	@SerializedName("life_cycle_stage")
	private String lifeCycleStage = null;

	@SerializedName("planned_deployment_date")
	private String plannedDeploymentDate = null;

	@SerializedName("last_update_time")
	private String lastUpdateTime = null;

	@SerializedName("is_latest_build")
	private Boolean isLatestBuild = null;

	@SerializedName("policy_name")
	private String policyName = null;

	@SerializedName("policy_version")
	private Long policyVersion = null;

	@SerializedName("policy_compliance_status")
	private String policyComplianceStatus = null;

	@SerializedName("policy_rules_status")
	private String policyRulesStatus = null;

	@SerializedName("grace_period_expired")
	private Boolean gracePeriodExpired = null;

	@SerializedName("scan_overdue")
	private String scanOverdue = null;

	@SerializedName("any_type_scan_due")
	private String anyTypeScanDue = null;

	@SerializedName("business_owner")
	private String businessOwner = null;

	@SerializedName("business_unit")
	private String businessUnit = null;

	@SerializedName("tags")
	private String tags = null;

	@SerializedName("legacy_scan_engine")
	private Boolean legacyScanEngine = null;

	/**
	 * Get staticAnalysis
	 * 
	 * @return staticAnalysis
	 **/
	public AnalysisType getStaticAnalysis() {
		return staticAnalysis;
	}

	public void setStaticAnalysis(AnalysisType staticAnalysis) {
		this.staticAnalysis = staticAnalysis;
	}

	/**
	 * Get dynamicAnalysis
	 * 
	 * @return dynamicAnalysis
	 **/
	public AnalysisType getDynamicAnalysis() {
		return dynamicAnalysis;
	}

	public void setDynamicAnalysis(AnalysisType dynamicAnalysis) {
		this.dynamicAnalysis = dynamicAnalysis;
	}

	/**
	 * Get manualAnalysis
	 * 
	 * @return manualAnalysis
	 **/
	public ManualAnalysisType getManualAnalysis() {
		return manualAnalysis;
	}

	public void setManualAnalysis(ManualAnalysisType manualAnalysis) {
		this.manualAnalysis = manualAnalysis;
	}

	/**
	 * Get severity
	 * 
	 * @return severity
	 **/
	public List<SeverityType> getSeverity() {
		return severity;
	}

	public void setSeverity(List<SeverityType> severity) {
		this.severity = severity;
	}

	/**
	 * Get flawStatus
	 * 
	 * @return flawStatus
	 **/
	public FlawStatusType getFlawStatus() {
		return flawStatus;
	}

	public void setFlawStatus(FlawStatusType flawStatus) {
		this.flawStatus = flawStatus;
	}

	/**
	 * Get customFields
	 * 
	 * @return customFields
	 **/
	public CustomFieldsType getCustomFields() {
		return customFields;
	}

	public void setCustomFields(CustomFieldsType customFields) {
		this.customFields = customFields;
	}

	/**
	 * Get softwareCompositionAnalysis
	 * 
	 * @return softwareCompositionAnalysis
	 **/
	public SoftwareCompositionAnalysis getSoftwareCompositionAnalysis() {
		return softwareCompositionAnalysis;
	}

	public void setSoftwareCompositionAnalysis(SoftwareCompositionAnalysis softwareCompositionAnalysis) {
		this.softwareCompositionAnalysis = softwareCompositionAnalysis;
	}

	/**
	 * Version of the format of this report.
	 * 
	 * @return reportFormatVersion
	 **/
	public String getReportFormatVersion() {
		return reportFormatVersion;
	}

	public void setReportFormatVersion(String reportFormatVersion) {
		this.reportFormatVersion = reportFormatVersion;
	}

	/**
	 * ID of the Veracode account.
	 * 
	 * @return accountId
	 **/
	public BigDecimal getAccountId() {
		return accountId;
	}

	public void setAccountId(BigDecimal accountId) {
		this.accountId = accountId;
	}

	/**
	 * Name of the scanned application.
	 * 
	 * @return appName
	 **/
	public String getAppName() {
		return appName;
	}

	public void setAppName(String appName) {
		this.appName = appName;
	}

	/**
	 * ID of the scanned application.
	 * 
	 * @return appId
	 **/
	public BigDecimal getAppId() {
		return appId;
	}

	public void setAppId(BigDecimal appId) {
		this.appId = appId;
	}

	/**
	 * ID for the scan.
	 * 
	 * @return analysisId
	 **/
	public BigDecimal getAnalysisId() {
		return analysisId;
	}

	public void setAnalysisId(BigDecimal analysisId) {
		this.analysisId = analysisId;
	}

	/**
	 * Unit ID for a static analysis.
	 * 
	 * @return staticAnalysisUnitId
	 **/
	public BigDecimal getStaticAnalysisUnitId() {
		return staticAnalysisUnitId;
	}

	public void setStaticAnalysisUnitId(BigDecimal staticAnalysisUnitId) {
		this.staticAnalysisUnitId = staticAnalysisUnitId;
	}

	/**
	 * Name of the development sandbox. Not applicable for a policy scan.
	 * 
	 * @return sandboxName
	 **/
	public String getSandboxName() {
		return sandboxName;
	}

	public void setSandboxName(String sandboxName) {
		this.sandboxName = sandboxName;
	}

	/**
	 * ID of the development sandbox. Not applicable for a policy scan.
	 * 
	 * @return sandboxId
	 **/
	public BigDecimal getSandboxId() {
		return sandboxId;
	}

	public void setSandboxId(BigDecimal sandboxId) {
		this.sandboxId = sandboxId;
	}

	/**
	 * Timestamp of the first time you submitted a build of this application to
	 * Veracode for scanning.
	 * 
	 * @return firstBuildSubmittedDate
	 **/
	public String getFirstBuildSubmittedDate() {
		return firstBuildSubmittedDate;
	}

	public void setFirstBuildSubmittedDate(String firstBuildSubmittedDate) {
		this.firstBuildSubmittedDate = firstBuildSubmittedDate;
	}

	/**
	 * Version label for the application.
	 * 
	 * @return version
	 **/
	public String getVersion() {
		return version;
	}

	public void setVersion(String version) {
		this.version = version;
	}

	/**
	 * ID of the build for the application.
	 * 
	 * @return buildId
	 **/
	public BigDecimal getBuildId() {
		return buildId;
	}

	public void setBuildId(BigDecimal buildId) {
		this.buildId = buildId;
	}

	/**
	 * Name of the vendor that provided the application, if applicable.
	 * 
	 * @return vendor
	 **/
	public String getVendor() {
		return vendor;
	}

	public void setVendor(String vendor) {
		this.vendor = vendor;
	}

	/**
	 * Name of the account or user that created the build.
	 * 
	 * @return submitter
	 **/
	public String getSubmitter() {
		return submitter;
	}

	public void setSubmitter(String submitter) {
		this.submitter = submitter;
	}

	/**
	 * Platform of the build for the application.
	 * 
	 * @return platform
	 **/
	public String getPlatform() {
		return platform;
	}

	public void setPlatform(String platform) {
		this.platform = platform;
	}

	/**
	 * Business criticality for the application.
	 * 
	 * @return businessCriticality
	 **/
	public Long getBusinessCriticality() {
		return businessCriticality;
	}

	public void setBusinessCriticality(Long businessCriticality) {
		this.businessCriticality = businessCriticality;
	}

	/**
	 * Timestamp when Veracode generated the report.
	 * 
	 * @return generationDate
	 **/
	public String getGenerationDate() {
		return generationDate;
	}

	public void setGenerationDate(String generationDate) {
		this.generationDate = generationDate;
	}

	/**
	 * Security score for the application based on Veracode Levels. Values are VL1,
	 * VL2, VL3, VL4, or VL5
	 * 
	 * @return veracodeLevel
	 **/
	public String getVeracodeLevel() {
		return veracodeLevel;
	}

	public void setVeracodeLevel(String veracodeLevel) {
		this.veracodeLevel = veracodeLevel;
	}

	/**
	 * Total number of discovered findings for the application.
	 * 
	 * @return totalFlaws
	 **/
	public Long getTotalFlaws() {
		return totalFlaws;
	}

	public void setTotalFlaws(Long totalFlaws) {
		this.totalFlaws = totalFlaws;
	}

	/**
	 * Total number of discovered findings not marked as mitigated.
	 * 
	 * @return flawsNotMitigated
	 **/
	public Long getFlawsNotMitigated() {
		return flawsNotMitigated;
	}

	public void setFlawsNotMitigated(Long flawsNotMitigated) {
		this.flawsNotMitigated = flawsNotMitigated;
	}

	/**
	 * Teams assigned to this application.
	 * 
	 * @return teams
	 **/
	public String getTeams() {
		return teams;
	}

	public void setTeams(String teams) {
		this.teams = teams;
	}

	/**
	 * Current life cycle stage for this application. For example, deployed or in
	 * development.
	 * 
	 * @return lifeCycleStage
	 **/
	public String getLifeCycleStage() {
		return lifeCycleStage;
	}

	public void setLifeCycleStage(String lifeCycleStage) {
		this.lifeCycleStage = lifeCycleStage;
	}

	/**
	 * Deployment date for the application, if specified.
	 * 
	 * @return plannedDeploymentDate
	 **/
	public String getPlannedDeploymentDate() {
		return plannedDeploymentDate;
	}

	public void setPlannedDeploymentDate(String plannedDeploymentDate) {
		this.plannedDeploymentDate = plannedDeploymentDate;
	}

	/**
	 * Last time this application was modified.
	 * 
	 * @return lastUpdateTime
	 **/
	public String getLastUpdateTime() {
		return lastUpdateTime;
	}

	public void setLastUpdateTime(String lastUpdateTime) {
		this.lastUpdateTime = lastUpdateTime;
	}

	/**
	 * True if this report is for the most recent build of this application.
	 * 
	 * @return isLatestBuild
	 **/
	public Boolean isIsLatestBuild() {
		return isLatestBuild;
	}

	public void setIsLatestBuild(Boolean isLatestBuild) {
		this.isLatestBuild = isLatestBuild;
	}

	/**
	 * Name of the security policy assigned to this application.
	 * 
	 * @return policyName
	 **/
	public String getPolicyName() {
		return policyName;
	}

	public void setPolicyName(String policyName) {
		this.policyName = policyName;
	}

	/**
	 * Version number of the security policy assigned to the version of this
	 * application.
	 * 
	 * @return policyVersion
	 **/
	public Long getPolicyVersion() {
		return policyVersion;
	}

	public void setPolicyVersion(Long policyVersion) {
		this.policyVersion = policyVersion;
	}

	/**
	 * Current policy compliance status for this application. Values are
	 * Calculating, Did Not Pass, Conditional Pass, or Pass.
	 * 
	 * @return policyComplianceStatus
	 **/
	public String getPolicyComplianceStatus() {
		return policyComplianceStatus;
	}

	public void setPolicyComplianceStatus(String policyComplianceStatus) {
		this.policyComplianceStatus = policyComplianceStatus;
	}

	/**
	 * Current policy rules compliance status for this application. Does not include
	 * scan frequency requirements and grace period time allowed to address rule
	 * violations. Values are Calculating, Did Not Pass, or Pass.
	 * 
	 * @return policyRulesStatus
	 **/
	public String getPolicyRulesStatus() {
		return policyRulesStatus;
	}

	public void setPolicyRulesStatus(String policyRulesStatus) {
		this.policyRulesStatus = policyRulesStatus;
	}

	/**
	 * True if findings in the latest analyzed build of this application have
	 * existed for longer than the allowed grace period.
	 * 
	 * @return gracePeriodExpired
	 **/
	public Boolean isGracePeriodExpired() {
		return gracePeriodExpired;
	}

	public void setGracePeriodExpired(Boolean gracePeriodExpired) {
		this.gracePeriodExpired = gracePeriodExpired;
	}

	/**
	 * True if the amount of time between the last analysis and the current time is
	 * greater than the scan frequency that your security policy requires.
	 * 
	 * @return scanOverdue
	 **/
	public String getScanOverdue() {
		return scanOverdue;
	}

	public void setScanOverdue(String scanOverdue) {
		this.scanOverdue = scanOverdue;
	}

	/**
	 * Date to analyze a new build of this application for it to remain in
	 * compliance with the required scan frequency of the security policy.
	 * 
	 * @return anyTypeScanDue
	 **/
	public String getAnyTypeScanDue() {
		return anyTypeScanDue;
	}

	public void setAnyTypeScanDue(String anyTypeScanDue) {
		this.anyTypeScanDue = anyTypeScanDue;
	}

	/**
	 * First and last name of the party responsible for this application.
	 * 
	 * @return businessOwner
	 **/
	public String getBusinessOwner() {
		return businessOwner;
	}

	public void setBusinessOwner(String businessOwner) {
		this.businessOwner = businessOwner;
	}

	/**
	 * Department or group associated with this application.
	 * 
	 * @return businessUnit
	 **/
	public String getBusinessUnit() {
		return businessUnit;
	}

	public void setBusinessUnit(String businessUnit) {
		this.businessUnit = businessUnit;
	}

	/**
	 * Comma-delimited list of tags associated with this application.
	 * 
	 * @return tags
	 **/
	public String getTags() {
		return tags;
	}

	public void setTags(String tags) {
		this.tags = tags;
	}

	/**
	 * For a static analysis, indicates whether the scan ran with a legacy engine or
	 * the same engine version as the previous scan of its type.
	 * 
	 * @return legacyScanEngine
	 **/
	public Boolean isLegacyScanEngine() {
		return legacyScanEngine;
	}

	public void setLegacyScanEngine(Boolean legacyScanEngine) {
		this.legacyScanEngine = legacyScanEngine;
	}

	@Override
	public boolean equals(java.lang.Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		SummaryReport summaryReport = (SummaryReport) o;
		return Objects.equals(this.staticAnalysis, summaryReport.staticAnalysis)
				&& Objects.equals(this.dynamicAnalysis, summaryReport.dynamicAnalysis)
				&& Objects.equals(this.manualAnalysis, summaryReport.manualAnalysis)
				&& Objects.equals(this.severity, summaryReport.severity)
				&& Objects.equals(this.flawStatus, summaryReport.flawStatus)
				&& Objects.equals(this.customFields, summaryReport.customFields)
				&& Objects.equals(this.softwareCompositionAnalysis, summaryReport.softwareCompositionAnalysis)
				&& Objects.equals(this.reportFormatVersion, summaryReport.reportFormatVersion)
				&& Objects.equals(this.accountId, summaryReport.accountId)
				&& Objects.equals(this.appName, summaryReport.appName)
				&& Objects.equals(this.appId, summaryReport.appId)
				&& Objects.equals(this.analysisId, summaryReport.analysisId)
				&& Objects.equals(this.staticAnalysisUnitId, summaryReport.staticAnalysisUnitId)
				&& Objects.equals(this.sandboxName, summaryReport.sandboxName)
				&& Objects.equals(this.sandboxId, summaryReport.sandboxId)
				&& Objects.equals(this.firstBuildSubmittedDate, summaryReport.firstBuildSubmittedDate)
				&& Objects.equals(this.version, summaryReport.version)
				&& Objects.equals(this.buildId, summaryReport.buildId)
				&& Objects.equals(this.vendor, summaryReport.vendor)
				&& Objects.equals(this.submitter, summaryReport.submitter)
				&& Objects.equals(this.platform, summaryReport.platform)
				&& Objects.equals(this.businessCriticality, summaryReport.businessCriticality)
				&& Objects.equals(this.generationDate, summaryReport.generationDate)
				&& Objects.equals(this.veracodeLevel, summaryReport.veracodeLevel)
				&& Objects.equals(this.totalFlaws, summaryReport.totalFlaws)
				&& Objects.equals(this.flawsNotMitigated, summaryReport.flawsNotMitigated)
				&& Objects.equals(this.teams, summaryReport.teams)
				&& Objects.equals(this.lifeCycleStage, summaryReport.lifeCycleStage)
				&& Objects.equals(this.plannedDeploymentDate, summaryReport.plannedDeploymentDate)
				&& Objects.equals(this.lastUpdateTime, summaryReport.lastUpdateTime)
				&& Objects.equals(this.isLatestBuild, summaryReport.isLatestBuild)
				&& Objects.equals(this.policyName, summaryReport.policyName)
				&& Objects.equals(this.policyVersion, summaryReport.policyVersion)
				&& Objects.equals(this.policyComplianceStatus, summaryReport.policyComplianceStatus)
				&& Objects.equals(this.policyRulesStatus, summaryReport.policyRulesStatus)
				&& Objects.equals(this.gracePeriodExpired, summaryReport.gracePeriodExpired)
				&& Objects.equals(this.scanOverdue, summaryReport.scanOverdue)
				&& Objects.equals(this.anyTypeScanDue, summaryReport.anyTypeScanDue)
				&& Objects.equals(this.businessOwner, summaryReport.businessOwner)
				&& Objects.equals(this.businessUnit, summaryReport.businessUnit)
				&& Objects.equals(this.tags, summaryReport.tags)
				&& Objects.equals(this.legacyScanEngine, summaryReport.legacyScanEngine);
	}

	@Override
	public int hashCode() {
		return Objects.hash(staticAnalysis, dynamicAnalysis, manualAnalysis, severity, flawStatus, customFields,
				softwareCompositionAnalysis, reportFormatVersion, accountId, appName, appId, analysisId,
				staticAnalysisUnitId, sandboxName, sandboxId, firstBuildSubmittedDate, version, buildId, vendor,
				submitter, platform, businessCriticality, generationDate, veracodeLevel, totalFlaws, flawsNotMitigated,
				teams, lifeCycleStage, plannedDeploymentDate, lastUpdateTime, isLatestBuild, policyName, policyVersion,
				policyComplianceStatus, policyRulesStatus, gracePeriodExpired, scanOverdue, anyTypeScanDue,
				businessOwner, businessUnit, tags, legacyScanEngine);
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("class SummaryReport {\n");

		sb.append("    staticAnalysis: ").append(toIndentedString(staticAnalysis)).append("\n");
		sb.append("    dynamicAnalysis: ").append(toIndentedString(dynamicAnalysis)).append("\n");
		sb.append("    manualAnalysis: ").append(toIndentedString(manualAnalysis)).append("\n");
		sb.append("    severity: ").append(toIndentedString(severity)).append("\n");
		sb.append("    flawStatus: ").append(toIndentedString(flawStatus)).append("\n");
		sb.append("    customFields: ").append(toIndentedString(customFields)).append("\n");
		sb.append("    softwareCompositionAnalysis: ").append(toIndentedString(softwareCompositionAnalysis))
				.append("\n");
		sb.append("    reportFormatVersion: ").append(toIndentedString(reportFormatVersion)).append("\n");
		sb.append("    accountId: ").append(toIndentedString(accountId)).append("\n");
		sb.append("    appName: ").append(toIndentedString(appName)).append("\n");
		sb.append("    appId: ").append(toIndentedString(appId)).append("\n");
		sb.append("    analysisId: ").append(toIndentedString(analysisId)).append("\n");
		sb.append("    staticAnalysisUnitId: ").append(toIndentedString(staticAnalysisUnitId)).append("\n");
		sb.append("    sandboxName: ").append(toIndentedString(sandboxName)).append("\n");
		sb.append("    sandboxId: ").append(toIndentedString(sandboxId)).append("\n");
		sb.append("    firstBuildSubmittedDate: ").append(toIndentedString(firstBuildSubmittedDate)).append("\n");
		sb.append("    version: ").append(toIndentedString(version)).append("\n");
		sb.append("    buildId: ").append(toIndentedString(buildId)).append("\n");
		sb.append("    vendor: ").append(toIndentedString(vendor)).append("\n");
		sb.append("    submitter: ").append(toIndentedString(submitter)).append("\n");
		sb.append("    platform: ").append(toIndentedString(platform)).append("\n");
		sb.append("    businessCriticality: ").append(toIndentedString(businessCriticality)).append("\n");
		sb.append("    generationDate: ").append(toIndentedString(generationDate)).append("\n");
		sb.append("    veracodeLevel: ").append(toIndentedString(veracodeLevel)).append("\n");
		sb.append("    totalFlaws: ").append(toIndentedString(totalFlaws)).append("\n");
		sb.append("    flawsNotMitigated: ").append(toIndentedString(flawsNotMitigated)).append("\n");
		sb.append("    teams: ").append(toIndentedString(teams)).append("\n");
		sb.append("    lifeCycleStage: ").append(toIndentedString(lifeCycleStage)).append("\n");
		sb.append("    plannedDeploymentDate: ").append(toIndentedString(plannedDeploymentDate)).append("\n");
		sb.append("    lastUpdateTime: ").append(toIndentedString(lastUpdateTime)).append("\n");
		sb.append("    isLatestBuild: ").append(toIndentedString(isLatestBuild)).append("\n");
		sb.append("    policyName: ").append(toIndentedString(policyName)).append("\n");
		sb.append("    policyVersion: ").append(toIndentedString(policyVersion)).append("\n");
		sb.append("    policyComplianceStatus: ").append(toIndentedString(policyComplianceStatus)).append("\n");
		sb.append("    policyRulesStatus: ").append(toIndentedString(policyRulesStatus)).append("\n");
		sb.append("    gracePeriodExpired: ").append(toIndentedString(gracePeriodExpired)).append("\n");
		sb.append("    scanOverdue: ").append(toIndentedString(scanOverdue)).append("\n");
		sb.append("    anyTypeScanDue: ").append(toIndentedString(anyTypeScanDue)).append("\n");
		sb.append("    businessOwner: ").append(toIndentedString(businessOwner)).append("\n");
		sb.append("    businessUnit: ").append(toIndentedString(businessUnit)).append("\n");
		sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
		sb.append("    legacyScanEngine: ").append(toIndentedString(legacyScanEngine)).append("\n");
		sb.append("}");
		return sb.toString();
	}

	/**
	 * Convert the given object to string with each line indented by 4 spaces
	 * (except the first line).
	 */
	private String toIndentedString(java.lang.Object o) {
		if (o == null) {
			return "null";
		}
		return o.toString().replace("\n", "\n    ");
	}

}
